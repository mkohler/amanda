# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.39
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Amanda::Config;
use base qw(Exporter);
use base qw(DynaLoader);
package Amanda::Configc;
bootstrap Amanda::Config;
package Amanda::Config;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Amanda::Config;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Amanda::Config;

*getconf = *Amanda::Configc::getconf;
*getconf_seen = *Amanda::Configc::getconf_seen;
*getconf_byname = *Amanda::Configc::getconf_byname;
*getconf_list = *Amanda::Configc::getconf_list;
*getconf_byname_strs = *Amanda::Configc::getconf_byname_strs;
*lookup_tapetype = *Amanda::Configc::lookup_tapetype;
*tapetype_getconf = *Amanda::Configc::tapetype_getconf;
*tapetype_name = *Amanda::Configc::tapetype_name;
*tapetype_seen = *Amanda::Configc::tapetype_seen;
*lookup_dumptype = *Amanda::Configc::lookup_dumptype;
*dumptype_getconf = *Amanda::Configc::dumptype_getconf;
*dumptype_name = *Amanda::Configc::dumptype_name;
*dumptype_seen = *Amanda::Configc::dumptype_seen;
*lookup_interface = *Amanda::Configc::lookup_interface;
*interface_getconf = *Amanda::Configc::interface_getconf;
*interface_name = *Amanda::Configc::interface_name;
*interface_seen = *Amanda::Configc::interface_seen;
*lookup_holdingdisk = *Amanda::Configc::lookup_holdingdisk;
*getconf_holdingdisks = *Amanda::Configc::getconf_holdingdisks;
*holdingdisk_next = *Amanda::Configc::holdingdisk_next;
*holdingdisk_getconf = *Amanda::Configc::holdingdisk_getconf;
*holdingdisk_name = *Amanda::Configc::holdingdisk_name;
*holdingdisk_seen = *Amanda::Configc::holdingdisk_seen;
*lookup_application = *Amanda::Configc::lookup_application;
*application_getconf = *Amanda::Configc::application_getconf;
*application_name = *Amanda::Configc::application_name;
*application_seen = *Amanda::Configc::application_seen;
*lookup_pp_script = *Amanda::Configc::lookup_pp_script;
*pp_script_getconf = *Amanda::Configc::pp_script_getconf;
*pp_script_name = *Amanda::Configc::pp_script_name;
*pp_script_seen = *Amanda::Configc::pp_script_seen;
*lookup_device_config = *Amanda::Configc::lookup_device_config;
*device_config_getconf = *Amanda::Configc::device_config_getconf;
*device_config_name = *Amanda::Configc::device_config_name;
*device_config_seen = *Amanda::Configc::device_config_seen;
*lookup_changer_config = *Amanda::Configc::lookup_changer_config;
*changer_config_getconf = *Amanda::Configc::changer_config_getconf;
*changer_config_name = *Amanda::Configc::changer_config_name;
*changer_config_seen = *Amanda::Configc::changer_config_seen;
*getconf_unit_divisor = *Amanda::Configc::getconf_unit_divisor;
*config_init = *Amanda::Configc::config_init;
*config_uninit = *Amanda::Configc::config_uninit;
*get_config_options = *Amanda::Configc::get_config_options;
*get_config_name = *Amanda::Configc::get_config_name;
*get_config_dir = *Amanda::Configc::get_config_dir;
*get_config_filename = *Amanda::Configc::get_config_filename;
*config_print_errors = *Amanda::Configc::config_print_errors;
*config_clear_errors = *Amanda::Configc::config_clear_errors;
*config_errors = *Amanda::Configc::config_errors;
*new_config_overwrites = *Amanda::Configc::new_config_overwrites;
*free_config_overwrites = *Amanda::Configc::free_config_overwrites;
*add_config_overwrite = *Amanda::Configc::add_config_overwrite;
*add_config_overwrite_opt = *Amanda::Configc::add_config_overwrite_opt;
*apply_config_overwrites = *Amanda::Configc::apply_config_overwrites;
*dump_configuration = *Amanda::Configc::dump_configuration;
*config_dir_relative = *Amanda::Configc::config_dir_relative;
*taperalgo2str = *Amanda::Configc::taperalgo2str;
*find_multiplier = *Amanda::Configc::find_multiplier;

# ------- VARIABLE STUBS --------

package Amanda::Config;

*CNF_ORG = *Amanda::Configc::CNF_ORG;
*CNF_CONF = *Amanda::Configc::CNF_CONF;
*CNF_INDEX_SERVER = *Amanda::Configc::CNF_INDEX_SERVER;
*CNF_TAPE_SERVER = *Amanda::Configc::CNF_TAPE_SERVER;
*CNF_AUTH = *Amanda::Configc::CNF_AUTH;
*CNF_SSH_KEYS = *Amanda::Configc::CNF_SSH_KEYS;
*CNF_AMANDAD_PATH = *Amanda::Configc::CNF_AMANDAD_PATH;
*CNF_CLIENT_USERNAME = *Amanda::Configc::CNF_CLIENT_USERNAME;
*CNF_GNUTAR_LIST_DIR = *Amanda::Configc::CNF_GNUTAR_LIST_DIR;
*CNF_AMANDATES = *Amanda::Configc::CNF_AMANDATES;
*CNF_MAILER = *Amanda::Configc::CNF_MAILER;
*CNF_MAILTO = *Amanda::Configc::CNF_MAILTO;
*CNF_DUMPUSER = *Amanda::Configc::CNF_DUMPUSER;
*CNF_TAPEDEV = *Amanda::Configc::CNF_TAPEDEV;
*CNF_DEVICE_PROPERTY = *Amanda::Configc::CNF_DEVICE_PROPERTY;
*CNF_PROPERTY = *Amanda::Configc::CNF_PROPERTY;
*CNF_CHANGERDEV = *Amanda::Configc::CNF_CHANGERDEV;
*CNF_CHANGERFILE = *Amanda::Configc::CNF_CHANGERFILE;
*CNF_LABELSTR = *Amanda::Configc::CNF_LABELSTR;
*CNF_TAPELIST = *Amanda::Configc::CNF_TAPELIST;
*CNF_DISKFILE = *Amanda::Configc::CNF_DISKFILE;
*CNF_INFOFILE = *Amanda::Configc::CNF_INFOFILE;
*CNF_LOGDIR = *Amanda::Configc::CNF_LOGDIR;
*CNF_INDEXDIR = *Amanda::Configc::CNF_INDEXDIR;
*CNF_TAPETYPE = *Amanda::Configc::CNF_TAPETYPE;
*CNF_DUMPCYCLE = *Amanda::Configc::CNF_DUMPCYCLE;
*CNF_RUNSPERCYCLE = *Amanda::Configc::CNF_RUNSPERCYCLE;
*CNF_TAPECYCLE = *Amanda::Configc::CNF_TAPECYCLE;
*CNF_NETUSAGE = *Amanda::Configc::CNF_NETUSAGE;
*CNF_INPARALLEL = *Amanda::Configc::CNF_INPARALLEL;
*CNF_DUMPORDER = *Amanda::Configc::CNF_DUMPORDER;
*CNF_BUMPPERCENT = *Amanda::Configc::CNF_BUMPPERCENT;
*CNF_BUMPSIZE = *Amanda::Configc::CNF_BUMPSIZE;
*CNF_BUMPMULT = *Amanda::Configc::CNF_BUMPMULT;
*CNF_BUMPDAYS = *Amanda::Configc::CNF_BUMPDAYS;
*CNF_TPCHANGER = *Amanda::Configc::CNF_TPCHANGER;
*CNF_RUNTAPES = *Amanda::Configc::CNF_RUNTAPES;
*CNF_MAXDUMPS = *Amanda::Configc::CNF_MAXDUMPS;
*CNF_ETIMEOUT = *Amanda::Configc::CNF_ETIMEOUT;
*CNF_DTIMEOUT = *Amanda::Configc::CNF_DTIMEOUT;
*CNF_CTIMEOUT = *Amanda::Configc::CNF_CTIMEOUT;
*CNF_TAPEBUFS = *Amanda::Configc::CNF_TAPEBUFS;
*CNF_DEVICE_OUTPUT_BUFFER_SIZE = *Amanda::Configc::CNF_DEVICE_OUTPUT_BUFFER_SIZE;
*CNF_PRINTER = *Amanda::Configc::CNF_PRINTER;
*CNF_AUTOFLUSH = *Amanda::Configc::CNF_AUTOFLUSH;
*CNF_RESERVE = *Amanda::Configc::CNF_RESERVE;
*CNF_MAXDUMPSIZE = *Amanda::Configc::CNF_MAXDUMPSIZE;
*CNF_COLUMNSPEC = *Amanda::Configc::CNF_COLUMNSPEC;
*CNF_AMRECOVER_DO_FSF = *Amanda::Configc::CNF_AMRECOVER_DO_FSF;
*CNF_AMRECOVER_CHECK_LABEL = *Amanda::Configc::CNF_AMRECOVER_CHECK_LABEL;
*CNF_AMRECOVER_CHANGER = *Amanda::Configc::CNF_AMRECOVER_CHANGER;
*CNF_TAPERALGO = *Amanda::Configc::CNF_TAPERALGO;
*CNF_FLUSH_THRESHOLD_DUMPED = *Amanda::Configc::CNF_FLUSH_THRESHOLD_DUMPED;
*CNF_FLUSH_THRESHOLD_SCHEDULED = *Amanda::Configc::CNF_FLUSH_THRESHOLD_SCHEDULED;
*CNF_TAPERFLUSH = *Amanda::Configc::CNF_TAPERFLUSH;
*CNF_DISPLAYUNIT = *Amanda::Configc::CNF_DISPLAYUNIT;
*CNF_KRB5KEYTAB = *Amanda::Configc::CNF_KRB5KEYTAB;
*CNF_KRB5PRINCIPAL = *Amanda::Configc::CNF_KRB5PRINCIPAL;
*CNF_LABEL_NEW_TAPES = *Amanda::Configc::CNF_LABEL_NEW_TAPES;
*CNF_USETIMESTAMPS = *Amanda::Configc::CNF_USETIMESTAMPS;
*CNF_REP_TRIES = *Amanda::Configc::CNF_REP_TRIES;
*CNF_CONNECT_TRIES = *Amanda::Configc::CNF_CONNECT_TRIES;
*CNF_REQ_TRIES = *Amanda::Configc::CNF_REQ_TRIES;
*CNF_DEBUG_AMANDAD = *Amanda::Configc::CNF_DEBUG_AMANDAD;
*CNF_DEBUG_AMIDXTAPED = *Amanda::Configc::CNF_DEBUG_AMIDXTAPED;
*CNF_DEBUG_AMINDEXD = *Amanda::Configc::CNF_DEBUG_AMINDEXD;
*CNF_DEBUG_AMRECOVER = *Amanda::Configc::CNF_DEBUG_AMRECOVER;
*CNF_DEBUG_AUTH = *Amanda::Configc::CNF_DEBUG_AUTH;
*CNF_DEBUG_EVENT = *Amanda::Configc::CNF_DEBUG_EVENT;
*CNF_DEBUG_HOLDING = *Amanda::Configc::CNF_DEBUG_HOLDING;
*CNF_DEBUG_PROTOCOL = *Amanda::Configc::CNF_DEBUG_PROTOCOL;
*CNF_DEBUG_PLANNER = *Amanda::Configc::CNF_DEBUG_PLANNER;
*CNF_DEBUG_DRIVER = *Amanda::Configc::CNF_DEBUG_DRIVER;
*CNF_DEBUG_DUMPER = *Amanda::Configc::CNF_DEBUG_DUMPER;
*CNF_DEBUG_CHUNKER = *Amanda::Configc::CNF_DEBUG_CHUNKER;
*CNF_DEBUG_TAPER = *Amanda::Configc::CNF_DEBUG_TAPER;
*CNF_DEBUG_SELFCHECK = *Amanda::Configc::CNF_DEBUG_SELFCHECK;
*CNF_DEBUG_SENDSIZE = *Amanda::Configc::CNF_DEBUG_SENDSIZE;
*CNF_DEBUG_SENDBACKUP = *Amanda::Configc::CNF_DEBUG_SENDBACKUP;
*CNF_RESERVED_UDP_PORT = *Amanda::Configc::CNF_RESERVED_UDP_PORT;
*CNF_RESERVED_TCP_PORT = *Amanda::Configc::CNF_RESERVED_TCP_PORT;
*CNF_UNRESERVED_TCP_PORT = *Amanda::Configc::CNF_UNRESERVED_TCP_PORT;
*TAPETYPE_COMMENT = *Amanda::Configc::TAPETYPE_COMMENT;
*TAPETYPE_LBL_TEMPL = *Amanda::Configc::TAPETYPE_LBL_TEMPL;
*TAPETYPE_BLOCKSIZE = *Amanda::Configc::TAPETYPE_BLOCKSIZE;
*TAPETYPE_READBLOCKSIZE = *Amanda::Configc::TAPETYPE_READBLOCKSIZE;
*TAPETYPE_LENGTH = *Amanda::Configc::TAPETYPE_LENGTH;
*TAPETYPE_FILEMARK = *Amanda::Configc::TAPETYPE_FILEMARK;
*TAPETYPE_SPEED = *Amanda::Configc::TAPETYPE_SPEED;
*TAPETYPE_FILE_PAD = *Amanda::Configc::TAPETYPE_FILE_PAD;
*DUMPTYPE_COMMENT = *Amanda::Configc::DUMPTYPE_COMMENT;
*DUMPTYPE_PROGRAM = *Amanda::Configc::DUMPTYPE_PROGRAM;
*DUMPTYPE_SRVCOMPPROG = *Amanda::Configc::DUMPTYPE_SRVCOMPPROG;
*DUMPTYPE_CLNTCOMPPROG = *Amanda::Configc::DUMPTYPE_CLNTCOMPPROG;
*DUMPTYPE_SRV_ENCRYPT = *Amanda::Configc::DUMPTYPE_SRV_ENCRYPT;
*DUMPTYPE_CLNT_ENCRYPT = *Amanda::Configc::DUMPTYPE_CLNT_ENCRYPT;
*DUMPTYPE_AMANDAD_PATH = *Amanda::Configc::DUMPTYPE_AMANDAD_PATH;
*DUMPTYPE_CLIENT_USERNAME = *Amanda::Configc::DUMPTYPE_CLIENT_USERNAME;
*DUMPTYPE_SSH_KEYS = *Amanda::Configc::DUMPTYPE_SSH_KEYS;
*DUMPTYPE_SECURITY_DRIVER = *Amanda::Configc::DUMPTYPE_SECURITY_DRIVER;
*DUMPTYPE_EXCLUDE = *Amanda::Configc::DUMPTYPE_EXCLUDE;
*DUMPTYPE_INCLUDE = *Amanda::Configc::DUMPTYPE_INCLUDE;
*DUMPTYPE_PRIORITY = *Amanda::Configc::DUMPTYPE_PRIORITY;
*DUMPTYPE_DUMPCYCLE = *Amanda::Configc::DUMPTYPE_DUMPCYCLE;
*DUMPTYPE_MAXDUMPS = *Amanda::Configc::DUMPTYPE_MAXDUMPS;
*DUMPTYPE_MAXPROMOTEDAY = *Amanda::Configc::DUMPTYPE_MAXPROMOTEDAY;
*DUMPTYPE_BUMPPERCENT = *Amanda::Configc::DUMPTYPE_BUMPPERCENT;
*DUMPTYPE_BUMPSIZE = *Amanda::Configc::DUMPTYPE_BUMPSIZE;
*DUMPTYPE_BUMPDAYS = *Amanda::Configc::DUMPTYPE_BUMPDAYS;
*DUMPTYPE_BUMPMULT = *Amanda::Configc::DUMPTYPE_BUMPMULT;
*DUMPTYPE_STARTTIME = *Amanda::Configc::DUMPTYPE_STARTTIME;
*DUMPTYPE_STRATEGY = *Amanda::Configc::DUMPTYPE_STRATEGY;
*DUMPTYPE_ESTIMATE = *Amanda::Configc::DUMPTYPE_ESTIMATE;
*DUMPTYPE_COMPRESS = *Amanda::Configc::DUMPTYPE_COMPRESS;
*DUMPTYPE_ENCRYPT = *Amanda::Configc::DUMPTYPE_ENCRYPT;
*DUMPTYPE_SRV_DECRYPT_OPT = *Amanda::Configc::DUMPTYPE_SRV_DECRYPT_OPT;
*DUMPTYPE_CLNT_DECRYPT_OPT = *Amanda::Configc::DUMPTYPE_CLNT_DECRYPT_OPT;
*DUMPTYPE_COMPRATE = *Amanda::Configc::DUMPTYPE_COMPRATE;
*DUMPTYPE_TAPE_SPLITSIZE = *Amanda::Configc::DUMPTYPE_TAPE_SPLITSIZE;
*DUMPTYPE_FALLBACK_SPLITSIZE = *Amanda::Configc::DUMPTYPE_FALLBACK_SPLITSIZE;
*DUMPTYPE_SPLIT_DISKBUFFER = *Amanda::Configc::DUMPTYPE_SPLIT_DISKBUFFER;
*DUMPTYPE_RECORD = *Amanda::Configc::DUMPTYPE_RECORD;
*DUMPTYPE_SKIP_INCR = *Amanda::Configc::DUMPTYPE_SKIP_INCR;
*DUMPTYPE_SKIP_FULL = *Amanda::Configc::DUMPTYPE_SKIP_FULL;
*DUMPTYPE_HOLDINGDISK = *Amanda::Configc::DUMPTYPE_HOLDINGDISK;
*DUMPTYPE_KENCRYPT = *Amanda::Configc::DUMPTYPE_KENCRYPT;
*DUMPTYPE_IGNORE = *Amanda::Configc::DUMPTYPE_IGNORE;
*DUMPTYPE_INDEX = *Amanda::Configc::DUMPTYPE_INDEX;
*DUMPTYPE_APPLICATION = *Amanda::Configc::DUMPTYPE_APPLICATION;
*DUMPTYPE_PP_SCRIPTLIST = *Amanda::Configc::DUMPTYPE_PP_SCRIPTLIST;
*DUMPTYPE_PROPERTY = *Amanda::Configc::DUMPTYPE_PROPERTY;
*INTER_COMMENT = *Amanda::Configc::INTER_COMMENT;
*INTER_MAXUSAGE = *Amanda::Configc::INTER_MAXUSAGE;
*HOLDING_COMMENT = *Amanda::Configc::HOLDING_COMMENT;
*HOLDING_DISKDIR = *Amanda::Configc::HOLDING_DISKDIR;
*HOLDING_DISKSIZE = *Amanda::Configc::HOLDING_DISKSIZE;
*HOLDING_CHUNKSIZE = *Amanda::Configc::HOLDING_CHUNKSIZE;
*APPLICATION_COMMENT = *Amanda::Configc::APPLICATION_COMMENT;
*APPLICATION_PLUGIN = *Amanda::Configc::APPLICATION_PLUGIN;
*APPLICATION_PROPERTY = *Amanda::Configc::APPLICATION_PROPERTY;
*PP_SCRIPT_COMMENT = *Amanda::Configc::PP_SCRIPT_COMMENT;
*PP_SCRIPT_PLUGIN = *Amanda::Configc::PP_SCRIPT_PLUGIN;
*PP_SCRIPT_PROPERTY = *Amanda::Configc::PP_SCRIPT_PROPERTY;
*PP_SCRIPT_EXECUTE_ON = *Amanda::Configc::PP_SCRIPT_EXECUTE_ON;
*PP_SCRIPT_EXECUTE_WHERE = *Amanda::Configc::PP_SCRIPT_EXECUTE_WHERE;
*DEVICE_CONFIG_COMMENT = *Amanda::Configc::DEVICE_CONFIG_COMMENT;
*DEVICE_CONFIG_TAPEDEV = *Amanda::Configc::DEVICE_CONFIG_TAPEDEV;
*DEVICE_CONFIG_DEVICE_PROPERTY = *Amanda::Configc::DEVICE_CONFIG_DEVICE_PROPERTY;
*CHANGER_CONFIG_COMMENT = *Amanda::Configc::CHANGER_CONFIG_COMMENT;
*CHANGER_CONFIG_TAPEDEV = *Amanda::Configc::CHANGER_CONFIG_TAPEDEV;
*CHANGER_CONFIG_TPCHANGER = *Amanda::Configc::CHANGER_CONFIG_TPCHANGER;
*CHANGER_CONFIG_CHANGERDEV = *Amanda::Configc::CHANGER_CONFIG_CHANGERDEV;
*CHANGER_CONFIG_CHANGERFILE = *Amanda::Configc::CHANGER_CONFIG_CHANGERFILE;
*HOLD_NEVER = *Amanda::Configc::HOLD_NEVER;
*HOLD_AUTO = *Amanda::Configc::HOLD_AUTO;
*HOLD_REQUIRED = *Amanda::Configc::HOLD_REQUIRED;
*COMP_NONE = *Amanda::Configc::COMP_NONE;
*COMP_FAST = *Amanda::Configc::COMP_FAST;
*COMP_BEST = *Amanda::Configc::COMP_BEST;
*COMP_CUST = *Amanda::Configc::COMP_CUST;
*COMP_SERVER_FAST = *Amanda::Configc::COMP_SERVER_FAST;
*COMP_SERVER_BEST = *Amanda::Configc::COMP_SERVER_BEST;
*COMP_SERVER_CUST = *Amanda::Configc::COMP_SERVER_CUST;
*ENCRYPT_NONE = *Amanda::Configc::ENCRYPT_NONE;
*ENCRYPT_CUST = *Amanda::Configc::ENCRYPT_CUST;
*ENCRYPT_SERV_CUST = *Amanda::Configc::ENCRYPT_SERV_CUST;
*DS_SKIP = *Amanda::Configc::DS_SKIP;
*DS_STANDARD = *Amanda::Configc::DS_STANDARD;
*DS_NOFULL = *Amanda::Configc::DS_NOFULL;
*DS_NOINC = *Amanda::Configc::DS_NOINC;
*DS_4 = *Amanda::Configc::DS_4;
*DS_5 = *Amanda::Configc::DS_5;
*DS_HANOI = *Amanda::Configc::DS_HANOI;
*DS_INCRONLY = *Amanda::Configc::DS_INCRONLY;
*ES_CLIENT = *Amanda::Configc::ES_CLIENT;
*ES_SERVER = *Amanda::Configc::ES_SERVER;
*ES_CALCSIZE = *Amanda::Configc::ES_CALCSIZE;
*ALGO_FIRST = *Amanda::Configc::ALGO_FIRST;
*ALGO_FIRSTFIT = *Amanda::Configc::ALGO_FIRSTFIT;
*ALGO_LARGEST = *Amanda::Configc::ALGO_LARGEST;
*ALGO_LARGESTFIT = *Amanda::Configc::ALGO_LARGESTFIT;
*ALGO_SMALLEST = *Amanda::Configc::ALGO_SMALLEST;
*ALGO_LAST = *Amanda::Configc::ALGO_LAST;
*EXECUTE_ON_PRE_DLE_AMCHECK = *Amanda::Configc::EXECUTE_ON_PRE_DLE_AMCHECK;
*EXECUTE_ON_PRE_HOST_AMCHECK = *Amanda::Configc::EXECUTE_ON_PRE_HOST_AMCHECK;
*EXECUTE_ON_POST_DLE_AMCHECK = *Amanda::Configc::EXECUTE_ON_POST_DLE_AMCHECK;
*EXECUTE_ON_POST_HOST_AMCHECK = *Amanda::Configc::EXECUTE_ON_POST_HOST_AMCHECK;
*EXECUTE_ON_PRE_DLE_ESTIMATE = *Amanda::Configc::EXECUTE_ON_PRE_DLE_ESTIMATE;
*EXECUTE_ON_PRE_HOST_ESTIMATE = *Amanda::Configc::EXECUTE_ON_PRE_HOST_ESTIMATE;
*EXECUTE_ON_POST_DLE_ESTIMATE = *Amanda::Configc::EXECUTE_ON_POST_DLE_ESTIMATE;
*EXECUTE_ON_POST_HOST_ESTIMATE = *Amanda::Configc::EXECUTE_ON_POST_HOST_ESTIMATE;
*EXECUTE_ON_PRE_DLE_BACKUP = *Amanda::Configc::EXECUTE_ON_PRE_DLE_BACKUP;
*EXECUTE_ON_PRE_HOST_BACKUP = *Amanda::Configc::EXECUTE_ON_PRE_HOST_BACKUP;
*EXECUTE_ON_POST_DLE_BACKUP = *Amanda::Configc::EXECUTE_ON_POST_DLE_BACKUP;
*EXECUTE_ON_POST_HOST_BACKUP = *Amanda::Configc::EXECUTE_ON_POST_HOST_BACKUP;
*SEND_AMREPORT_ALL = *Amanda::Configc::SEND_AMREPORT_ALL;
*SEND_AMREPORT_STRANGE = *Amanda::Configc::SEND_AMREPORT_STRANGE;
*SEND_AMREPORT_ERROR = *Amanda::Configc::SEND_AMREPORT_ERROR;
*SEND_AMREPORT_NEVER = *Amanda::Configc::SEND_AMREPORT_NEVER;
*debug_amandad = *Amanda::Configc::debug_amandad;
*debug_amidxtaped = *Amanda::Configc::debug_amidxtaped;
*debug_amindexd = *Amanda::Configc::debug_amindexd;
*debug_amrecover = *Amanda::Configc::debug_amrecover;
*debug_auth = *Amanda::Configc::debug_auth;
*debug_event = *Amanda::Configc::debug_event;
*debug_holding = *Amanda::Configc::debug_holding;
*debug_protocol = *Amanda::Configc::debug_protocol;
*debug_planner = *Amanda::Configc::debug_planner;
*debug_driver = *Amanda::Configc::debug_driver;
*debug_dumper = *Amanda::Configc::debug_dumper;
*debug_chunker = *Amanda::Configc::debug_chunker;
*debug_taper = *Amanda::Configc::debug_taper;
*debug_selfcheck = *Amanda::Configc::debug_selfcheck;
*debug_sendsize = *Amanda::Configc::debug_sendsize;
*debug_sendbackup = *Amanda::Configc::debug_sendbackup;
*CFGERR_OK = *Amanda::Configc::CFGERR_OK;
*CFGERR_WARNINGS = *Amanda::Configc::CFGERR_WARNINGS;
*CFGERR_ERRORS = *Amanda::Configc::CFGERR_ERRORS;
*CONFIG_INIT_EXPLICIT_NAME = *Amanda::Configc::CONFIG_INIT_EXPLICIT_NAME;
*CONFIG_INIT_USE_CWD = *Amanda::Configc::CONFIG_INIT_USE_CWD;
*CONFIG_INIT_CLIENT = *Amanda::Configc::CONFIG_INIT_CLIENT;
*CONFIG_INIT_OVERLAY = *Amanda::Configc::CONFIG_INIT_OVERLAY;

@EXPORT_OK = ();
%EXPORT_TAGS = ();

=head1 NAME

Amanda::Config - access to Amanda configuration parameters

=head1 SYNOPSIS

  use Amanda::Config qw( :init :getconf );

  config_init($CONFIG_INIT_EXPLICIT_NAME, $ARGV[1])
    or die("errors processing config file " . $Amanda::Config::get_config_filename());

  print "tape device is ", getconf($CNF_TAPEDEV), "\n";

This API closely parallels the C API.  See F<conffile.h> for details
on the functions and constants available here.

=head1 API STATUS

Stable

=head1 INITIALIZATION

The Amanda configuration is treated as a global state for the
application.  It is not possible to load two configurations
simultaneously.

All initialization-related symbols can be imported with the tag
C<:init>.

=head2 LOADING CONFIGURATION

The Amanda configuration is loaded with the aptly named
C<config_init($flags, $name)>.  Because of the great variety in
invocation method among Amanda applications, this function has a number
of flags that affect its behavior.  These flags can be OR'd together.

=over

=item If C<CONFIG_INIT_EXPLICIT_NAME> is given, then the C<$name>
parameter can contain the name of a configuration to load.

=item If C<CONFIG_INIT_USE_CWD> is given, and if the current directory
contains C<amanda.conf>, then that file is loaded.

=item If C<CONFIG_INIT_CLIENT> is given, then a client configuration
is loaded.

=item If C<CONFIG_INIT_OVERLAY> is given, then any existing
configuration is not reset.

=back

See C<conffile.h> for more detailed information on these flags and
their interactions.

C<config_uninit()> reverses the effects of C<config_init>.  It is
not often used.

Once the configuration is loaded, the configuration name
(e.g., "DailySet1"), directory (C</etc/amanda/DailySet1>),
and filename (C</etc/amanda/DailySet1/amanda.conf>) are
available from C<get_config_name()>, C<get_config_dir()>, and
C<get_config_filename()>, respectively.

=head3 CONFIG ERRORS

This module collects configuration errors and warnings in a list, and also
tracks the overall error level with an enumeration: C<$CFGERR_OK>,
C<$CFGERR_WARNINGS>, and C<$CFGERR_ERRORS>.  C<config_init> and
C<apply_config_overwrites> both return the current level.  The level and the
list of error messages are available from C<config_errors>:

  my ($cfgerr_level, @errors) = Amanda::Configconfig_errors();

As a convenience, C<config_print_errors> will print all error messages to
stderr.  The error state can be cleared with C<config_clear_errors>.

=head2 CONFIG OVERWRITES

Most Amanda applications accept the command-line option C<-o>
to "overwrite" configuration values in C<amanda.conf>.  In Perl
applications, these options should be parsed with L<Getopt::Long|Getopt::Long>, with
the action being a call to C<add_config_overwrite_opt>.  For example:

  my $config_overwrites = new_config_overwrites($#ARGV+1);
    GetOptions(
	# ...
	'o=s' => sub { add_config_overwrite_opt($config_overwrites, $_[1]); },
    ) or usage();
  my $cfg_ok = config_init($CONFIG_INIT_EXPLICIT_NAME | $CONFIG_INIT_USE_CWD, $config_name);
  apply_config_overwrites($config_overwrites);

C<new_config_overwrites($size_estimate)> creates a new
overwrites object, using the given size as an estimate of
the number of items it will contain (C<$#ARGC/2> is a good
estimate).  Individual configuration options are then added via
C<add_config_overwrite($co, $key, $value)> (which takes a key/value
pair) or C<add_config_overwrite_opt($co, $optarg)>, which parses a
string following C<-o> on the command line.

Once the overwrites are gathered, they are applied with
C<apply_config_overwrites($co)>, which applies the overwrites to the
active configuration.  No further operations can be performed on the
overwrites object after C<apply_config_overwrites> has been called.

The utility function C<get_config_options()> returns a list of
command-line arguments to represent any overwrites that were used
to generate the current configuration.  (TODO: this function isn't
available yet)

=head1 PARAMETER ACCESS

Amanda configurations consist of "global" parameters and several
sets of "subsections" -- one set for dumptypes, one for tapetypes,
and so on.

All of the global parameters are represented by a constant beginning
with C<$CNF_>, e.g., C<$CNF_LABELSTR>.  The function C<getconf($cnf)>
returns the value of parameter C<$cnf>, in whatever format is
appropriate for the parameter.  C<getconf_seen($cnf)> returns a true
value if C<$cnf> was seen in the configuration file.  If it was not
seen, then it will have its default value.

Some parameters have enumerated types.  The values for those
enumerations are available from this module with the same name as
in C<conffile.h>.  For example, C<$CNF_TAPERALGO> will yield a value
from the enumeration C<taperalgo_t>, the constants for which all
begin with C<$ALGO_>.  See C<conffile.h> for the details.

Each subsection type has the following functions:

=over

=item C<lookup_TYP($subsec_name)>

which returns an opaque object
(C<$ss>) representing the subsection, or C<undef> if no subsection
with that name exists;

=item C<TYP_name($ss)>

returning the name of the subsection;

=item C<TYP_getconf($ss, $cnf)>

which fetches a parameter value from C<$ss>; and

=item C<TYP_seen($ss, $cnf)>

which returns a true value if <$cnf> was seen in the subsection.

=back

The subsections are:

=over

=item C<tapetype>

with constants beginning with C<$TAPETYPE_>

=item C<dumptype>

with constants beginning with C<$DUMPTYPE_>

=item C<interface>

with constants beginning with C<$INTER_>

=item C<holdingdisk>

with constants beginning with C<$HOLDING_>

=item C<application>

with constants beginning with C<$APPLICATION_>

=item C<script>

with constants beginning with C<$PP_SCRIPT_>

=item C<device>

with constants beginning with C<$DEVICE_CONFIG_>.

=item C<changer>

with constants beginning with C<$CHANGER_CONFIG_>.

=back

See C<conffile.h> for the names of the constants themselves.

Parameter values are available by name from C<getconf_byname($name)> and
C<getconf_byname_strs($name, $str_needs_quotes)>.  These functions implement
the C<TYP:NAME:PARAM> syntax advertised by C<amgetconf> to access values in
subsections.  The first function returns a perl value, while the second returns
a string suitable for use in C<amanda.conf>, including quotes around strings if
C<$str_needs_quotes> is true.

C<getconf_list($typ)> returns a list of the names of all subsections of the
given type.  C<%subsection_names> is a hash whose keys are allowed subsection
names.

The C<$CNF_DISPLAYUNIT> implies a certain divisor to convert from
kilobytes to the desired unit.  This divisor is available from
C<getconf_unit_divisor()>.  Note carefully that it is a I<divisor>
for a value in I<kilobytes>!

Finally, various subsections of Amanda enable verbose debugging via
configuration parameters.  The status of each parameter is available
a similarly-named variable, e.g., C<$debug_auth>.

All parameter access functions and constants can be imported with
the tag C<:getconf>.

=head1 MISCELLANEOUS

These functions defy categorization.

The function C<config_dir_relative> will interpret a path relative to
the current configuration directory.  Absolute paths are passed through
unchanged, while relative paths are converted to absolute paths.

C<dump_configuration()> dumps the current configuration, in a format
suitable for re-evaluation for this module, to standard output.
This function may be revised to return a string.

Several parts of Amanda need to convert unit modifier value like
"gbytes" to a multiplier.  The function C<find_multiplier($str)>
returns the unit multiplier for such a string.  For example, "mbytes"
is converted to 1048576 (1024*1024).

=cut

push @EXPORT_OK, qw(confparm_key_to_string);
push @{$EXPORT_TAGS{"confparm_key"}}, qw(confparm_key_to_string);

my %_confparm_key_VALUES;
#Convert an enum value to a single string
sub confparm_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_confparm_key_VALUES) {
	my $v = $_confparm_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($CNF_ORG);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_ORG);

$_confparm_key_VALUES{"CNF_ORG"} = $CNF_ORG;

push @EXPORT_OK, qw($CNF_CONF);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CONF);

$_confparm_key_VALUES{"CNF_CONF"} = $CNF_CONF;

push @EXPORT_OK, qw($CNF_INDEX_SERVER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_INDEX_SERVER);

$_confparm_key_VALUES{"CNF_INDEX_SERVER"} = $CNF_INDEX_SERVER;

push @EXPORT_OK, qw($CNF_TAPE_SERVER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPE_SERVER);

$_confparm_key_VALUES{"CNF_TAPE_SERVER"} = $CNF_TAPE_SERVER;

push @EXPORT_OK, qw($CNF_AUTH);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AUTH);

$_confparm_key_VALUES{"CNF_AUTH"} = $CNF_AUTH;

push @EXPORT_OK, qw($CNF_SSH_KEYS);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_SSH_KEYS);

$_confparm_key_VALUES{"CNF_SSH_KEYS"} = $CNF_SSH_KEYS;

push @EXPORT_OK, qw($CNF_AMANDAD_PATH);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AMANDAD_PATH);

$_confparm_key_VALUES{"CNF_AMANDAD_PATH"} = $CNF_AMANDAD_PATH;

push @EXPORT_OK, qw($CNF_CLIENT_USERNAME);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CLIENT_USERNAME);

$_confparm_key_VALUES{"CNF_CLIENT_USERNAME"} = $CNF_CLIENT_USERNAME;

push @EXPORT_OK, qw($CNF_GNUTAR_LIST_DIR);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_GNUTAR_LIST_DIR);

$_confparm_key_VALUES{"CNF_GNUTAR_LIST_DIR"} = $CNF_GNUTAR_LIST_DIR;

push @EXPORT_OK, qw($CNF_AMANDATES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AMANDATES);

$_confparm_key_VALUES{"CNF_AMANDATES"} = $CNF_AMANDATES;

push @EXPORT_OK, qw($CNF_MAILER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_MAILER);

$_confparm_key_VALUES{"CNF_MAILER"} = $CNF_MAILER;

push @EXPORT_OK, qw($CNF_MAILTO);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_MAILTO);

$_confparm_key_VALUES{"CNF_MAILTO"} = $CNF_MAILTO;

push @EXPORT_OK, qw($CNF_DUMPUSER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DUMPUSER);

$_confparm_key_VALUES{"CNF_DUMPUSER"} = $CNF_DUMPUSER;

push @EXPORT_OK, qw($CNF_TAPEDEV);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPEDEV);

$_confparm_key_VALUES{"CNF_TAPEDEV"} = $CNF_TAPEDEV;

push @EXPORT_OK, qw($CNF_DEVICE_PROPERTY);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEVICE_PROPERTY);

$_confparm_key_VALUES{"CNF_DEVICE_PROPERTY"} = $CNF_DEVICE_PROPERTY;

push @EXPORT_OK, qw($CNF_PROPERTY);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_PROPERTY);

$_confparm_key_VALUES{"CNF_PROPERTY"} = $CNF_PROPERTY;

push @EXPORT_OK, qw($CNF_CHANGERDEV);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CHANGERDEV);

$_confparm_key_VALUES{"CNF_CHANGERDEV"} = $CNF_CHANGERDEV;

push @EXPORT_OK, qw($CNF_CHANGERFILE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CHANGERFILE);

$_confparm_key_VALUES{"CNF_CHANGERFILE"} = $CNF_CHANGERFILE;

push @EXPORT_OK, qw($CNF_LABELSTR);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_LABELSTR);

$_confparm_key_VALUES{"CNF_LABELSTR"} = $CNF_LABELSTR;

push @EXPORT_OK, qw($CNF_TAPELIST);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPELIST);

$_confparm_key_VALUES{"CNF_TAPELIST"} = $CNF_TAPELIST;

push @EXPORT_OK, qw($CNF_DISKFILE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DISKFILE);

$_confparm_key_VALUES{"CNF_DISKFILE"} = $CNF_DISKFILE;

push @EXPORT_OK, qw($CNF_INFOFILE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_INFOFILE);

$_confparm_key_VALUES{"CNF_INFOFILE"} = $CNF_INFOFILE;

push @EXPORT_OK, qw($CNF_LOGDIR);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_LOGDIR);

$_confparm_key_VALUES{"CNF_LOGDIR"} = $CNF_LOGDIR;

push @EXPORT_OK, qw($CNF_INDEXDIR);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_INDEXDIR);

$_confparm_key_VALUES{"CNF_INDEXDIR"} = $CNF_INDEXDIR;

push @EXPORT_OK, qw($CNF_TAPETYPE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPETYPE);

$_confparm_key_VALUES{"CNF_TAPETYPE"} = $CNF_TAPETYPE;

push @EXPORT_OK, qw($CNF_DUMPCYCLE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DUMPCYCLE);

$_confparm_key_VALUES{"CNF_DUMPCYCLE"} = $CNF_DUMPCYCLE;

push @EXPORT_OK, qw($CNF_RUNSPERCYCLE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_RUNSPERCYCLE);

$_confparm_key_VALUES{"CNF_RUNSPERCYCLE"} = $CNF_RUNSPERCYCLE;

push @EXPORT_OK, qw($CNF_TAPECYCLE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPECYCLE);

$_confparm_key_VALUES{"CNF_TAPECYCLE"} = $CNF_TAPECYCLE;

push @EXPORT_OK, qw($CNF_NETUSAGE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_NETUSAGE);

$_confparm_key_VALUES{"CNF_NETUSAGE"} = $CNF_NETUSAGE;

push @EXPORT_OK, qw($CNF_INPARALLEL);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_INPARALLEL);

$_confparm_key_VALUES{"CNF_INPARALLEL"} = $CNF_INPARALLEL;

push @EXPORT_OK, qw($CNF_DUMPORDER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DUMPORDER);

$_confparm_key_VALUES{"CNF_DUMPORDER"} = $CNF_DUMPORDER;

push @EXPORT_OK, qw($CNF_BUMPPERCENT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_BUMPPERCENT);

$_confparm_key_VALUES{"CNF_BUMPPERCENT"} = $CNF_BUMPPERCENT;

push @EXPORT_OK, qw($CNF_BUMPSIZE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_BUMPSIZE);

$_confparm_key_VALUES{"CNF_BUMPSIZE"} = $CNF_BUMPSIZE;

push @EXPORT_OK, qw($CNF_BUMPMULT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_BUMPMULT);

$_confparm_key_VALUES{"CNF_BUMPMULT"} = $CNF_BUMPMULT;

push @EXPORT_OK, qw($CNF_BUMPDAYS);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_BUMPDAYS);

$_confparm_key_VALUES{"CNF_BUMPDAYS"} = $CNF_BUMPDAYS;

push @EXPORT_OK, qw($CNF_TPCHANGER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TPCHANGER);

$_confparm_key_VALUES{"CNF_TPCHANGER"} = $CNF_TPCHANGER;

push @EXPORT_OK, qw($CNF_RUNTAPES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_RUNTAPES);

$_confparm_key_VALUES{"CNF_RUNTAPES"} = $CNF_RUNTAPES;

push @EXPORT_OK, qw($CNF_MAXDUMPS);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_MAXDUMPS);

$_confparm_key_VALUES{"CNF_MAXDUMPS"} = $CNF_MAXDUMPS;

push @EXPORT_OK, qw($CNF_ETIMEOUT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_ETIMEOUT);

$_confparm_key_VALUES{"CNF_ETIMEOUT"} = $CNF_ETIMEOUT;

push @EXPORT_OK, qw($CNF_DTIMEOUT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DTIMEOUT);

$_confparm_key_VALUES{"CNF_DTIMEOUT"} = $CNF_DTIMEOUT;

push @EXPORT_OK, qw($CNF_CTIMEOUT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CTIMEOUT);

$_confparm_key_VALUES{"CNF_CTIMEOUT"} = $CNF_CTIMEOUT;

push @EXPORT_OK, qw($CNF_TAPEBUFS);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPEBUFS);

$_confparm_key_VALUES{"CNF_TAPEBUFS"} = $CNF_TAPEBUFS;

push @EXPORT_OK, qw($CNF_DEVICE_OUTPUT_BUFFER_SIZE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEVICE_OUTPUT_BUFFER_SIZE);

$_confparm_key_VALUES{"CNF_DEVICE_OUTPUT_BUFFER_SIZE"} = $CNF_DEVICE_OUTPUT_BUFFER_SIZE;

push @EXPORT_OK, qw($CNF_PRINTER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_PRINTER);

$_confparm_key_VALUES{"CNF_PRINTER"} = $CNF_PRINTER;

push @EXPORT_OK, qw($CNF_AUTOFLUSH);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AUTOFLUSH);

$_confparm_key_VALUES{"CNF_AUTOFLUSH"} = $CNF_AUTOFLUSH;

push @EXPORT_OK, qw($CNF_RESERVE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_RESERVE);

$_confparm_key_VALUES{"CNF_RESERVE"} = $CNF_RESERVE;

push @EXPORT_OK, qw($CNF_MAXDUMPSIZE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_MAXDUMPSIZE);

$_confparm_key_VALUES{"CNF_MAXDUMPSIZE"} = $CNF_MAXDUMPSIZE;

push @EXPORT_OK, qw($CNF_COLUMNSPEC);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_COLUMNSPEC);

$_confparm_key_VALUES{"CNF_COLUMNSPEC"} = $CNF_COLUMNSPEC;

push @EXPORT_OK, qw($CNF_AMRECOVER_DO_FSF);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AMRECOVER_DO_FSF);

$_confparm_key_VALUES{"CNF_AMRECOVER_DO_FSF"} = $CNF_AMRECOVER_DO_FSF;

push @EXPORT_OK, qw($CNF_AMRECOVER_CHECK_LABEL);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AMRECOVER_CHECK_LABEL);

$_confparm_key_VALUES{"CNF_AMRECOVER_CHECK_LABEL"} = $CNF_AMRECOVER_CHECK_LABEL;

push @EXPORT_OK, qw($CNF_AMRECOVER_CHANGER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_AMRECOVER_CHANGER);

$_confparm_key_VALUES{"CNF_AMRECOVER_CHANGER"} = $CNF_AMRECOVER_CHANGER;

push @EXPORT_OK, qw($CNF_TAPERALGO);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPERALGO);

$_confparm_key_VALUES{"CNF_TAPERALGO"} = $CNF_TAPERALGO;

push @EXPORT_OK, qw($CNF_FLUSH_THRESHOLD_DUMPED);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_FLUSH_THRESHOLD_DUMPED);

$_confparm_key_VALUES{"CNF_FLUSH_THRESHOLD_DUMPED"} = $CNF_FLUSH_THRESHOLD_DUMPED;

push @EXPORT_OK, qw($CNF_FLUSH_THRESHOLD_SCHEDULED);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_FLUSH_THRESHOLD_SCHEDULED);

$_confparm_key_VALUES{"CNF_FLUSH_THRESHOLD_SCHEDULED"} = $CNF_FLUSH_THRESHOLD_SCHEDULED;

push @EXPORT_OK, qw($CNF_TAPERFLUSH);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_TAPERFLUSH);

$_confparm_key_VALUES{"CNF_TAPERFLUSH"} = $CNF_TAPERFLUSH;

push @EXPORT_OK, qw($CNF_DISPLAYUNIT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DISPLAYUNIT);

$_confparm_key_VALUES{"CNF_DISPLAYUNIT"} = $CNF_DISPLAYUNIT;

push @EXPORT_OK, qw($CNF_KRB5KEYTAB);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_KRB5KEYTAB);

$_confparm_key_VALUES{"CNF_KRB5KEYTAB"} = $CNF_KRB5KEYTAB;

push @EXPORT_OK, qw($CNF_KRB5PRINCIPAL);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_KRB5PRINCIPAL);

$_confparm_key_VALUES{"CNF_KRB5PRINCIPAL"} = $CNF_KRB5PRINCIPAL;

push @EXPORT_OK, qw($CNF_LABEL_NEW_TAPES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_LABEL_NEW_TAPES);

$_confparm_key_VALUES{"CNF_LABEL_NEW_TAPES"} = $CNF_LABEL_NEW_TAPES;

push @EXPORT_OK, qw($CNF_USETIMESTAMPS);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_USETIMESTAMPS);

$_confparm_key_VALUES{"CNF_USETIMESTAMPS"} = $CNF_USETIMESTAMPS;

push @EXPORT_OK, qw($CNF_REP_TRIES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_REP_TRIES);

$_confparm_key_VALUES{"CNF_REP_TRIES"} = $CNF_REP_TRIES;

push @EXPORT_OK, qw($CNF_CONNECT_TRIES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_CONNECT_TRIES);

$_confparm_key_VALUES{"CNF_CONNECT_TRIES"} = $CNF_CONNECT_TRIES;

push @EXPORT_OK, qw($CNF_REQ_TRIES);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_REQ_TRIES);

$_confparm_key_VALUES{"CNF_REQ_TRIES"} = $CNF_REQ_TRIES;

push @EXPORT_OK, qw($CNF_DEBUG_AMANDAD);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_AMANDAD);

$_confparm_key_VALUES{"CNF_DEBUG_AMANDAD"} = $CNF_DEBUG_AMANDAD;

push @EXPORT_OK, qw($CNF_DEBUG_AMIDXTAPED);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_AMIDXTAPED);

$_confparm_key_VALUES{"CNF_DEBUG_AMIDXTAPED"} = $CNF_DEBUG_AMIDXTAPED;

push @EXPORT_OK, qw($CNF_DEBUG_AMINDEXD);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_AMINDEXD);

$_confparm_key_VALUES{"CNF_DEBUG_AMINDEXD"} = $CNF_DEBUG_AMINDEXD;

push @EXPORT_OK, qw($CNF_DEBUG_AMRECOVER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_AMRECOVER);

$_confparm_key_VALUES{"CNF_DEBUG_AMRECOVER"} = $CNF_DEBUG_AMRECOVER;

push @EXPORT_OK, qw($CNF_DEBUG_AUTH);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_AUTH);

$_confparm_key_VALUES{"CNF_DEBUG_AUTH"} = $CNF_DEBUG_AUTH;

push @EXPORT_OK, qw($CNF_DEBUG_EVENT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_EVENT);

$_confparm_key_VALUES{"CNF_DEBUG_EVENT"} = $CNF_DEBUG_EVENT;

push @EXPORT_OK, qw($CNF_DEBUG_HOLDING);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_HOLDING);

$_confparm_key_VALUES{"CNF_DEBUG_HOLDING"} = $CNF_DEBUG_HOLDING;

push @EXPORT_OK, qw($CNF_DEBUG_PROTOCOL);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_PROTOCOL);

$_confparm_key_VALUES{"CNF_DEBUG_PROTOCOL"} = $CNF_DEBUG_PROTOCOL;

push @EXPORT_OK, qw($CNF_DEBUG_PLANNER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_PLANNER);

$_confparm_key_VALUES{"CNF_DEBUG_PLANNER"} = $CNF_DEBUG_PLANNER;

push @EXPORT_OK, qw($CNF_DEBUG_DRIVER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_DRIVER);

$_confparm_key_VALUES{"CNF_DEBUG_DRIVER"} = $CNF_DEBUG_DRIVER;

push @EXPORT_OK, qw($CNF_DEBUG_DUMPER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_DUMPER);

$_confparm_key_VALUES{"CNF_DEBUG_DUMPER"} = $CNF_DEBUG_DUMPER;

push @EXPORT_OK, qw($CNF_DEBUG_CHUNKER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_CHUNKER);

$_confparm_key_VALUES{"CNF_DEBUG_CHUNKER"} = $CNF_DEBUG_CHUNKER;

push @EXPORT_OK, qw($CNF_DEBUG_TAPER);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_TAPER);

$_confparm_key_VALUES{"CNF_DEBUG_TAPER"} = $CNF_DEBUG_TAPER;

push @EXPORT_OK, qw($CNF_DEBUG_SELFCHECK);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_SELFCHECK);

$_confparm_key_VALUES{"CNF_DEBUG_SELFCHECK"} = $CNF_DEBUG_SELFCHECK;

push @EXPORT_OK, qw($CNF_DEBUG_SENDSIZE);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_SENDSIZE);

$_confparm_key_VALUES{"CNF_DEBUG_SENDSIZE"} = $CNF_DEBUG_SENDSIZE;

push @EXPORT_OK, qw($CNF_DEBUG_SENDBACKUP);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_DEBUG_SENDBACKUP);

$_confparm_key_VALUES{"CNF_DEBUG_SENDBACKUP"} = $CNF_DEBUG_SENDBACKUP;

push @EXPORT_OK, qw($CNF_RESERVED_UDP_PORT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_RESERVED_UDP_PORT);

$_confparm_key_VALUES{"CNF_RESERVED_UDP_PORT"} = $CNF_RESERVED_UDP_PORT;

push @EXPORT_OK, qw($CNF_RESERVED_TCP_PORT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_RESERVED_TCP_PORT);

$_confparm_key_VALUES{"CNF_RESERVED_TCP_PORT"} = $CNF_RESERVED_TCP_PORT;

push @EXPORT_OK, qw($CNF_UNRESERVED_TCP_PORT);
push @{$EXPORT_TAGS{"confparm_key"}}, qw($CNF_UNRESERVED_TCP_PORT);

$_confparm_key_VALUES{"CNF_UNRESERVED_TCP_PORT"} = $CNF_UNRESERVED_TCP_PORT;

#copy symbols in confparm_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"confparm_key"}};

push @EXPORT_OK, qw(tapetype_key_to_string);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw(tapetype_key_to_string);

my %_tapetype_key_VALUES;
#Convert an enum value to a single string
sub tapetype_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_tapetype_key_VALUES) {
	my $v = $_tapetype_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($TAPETYPE_COMMENT);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_COMMENT);

$_tapetype_key_VALUES{"TAPETYPE_COMMENT"} = $TAPETYPE_COMMENT;

push @EXPORT_OK, qw($TAPETYPE_LBL_TEMPL);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_LBL_TEMPL);

$_tapetype_key_VALUES{"TAPETYPE_LBL_TEMPL"} = $TAPETYPE_LBL_TEMPL;

push @EXPORT_OK, qw($TAPETYPE_BLOCKSIZE);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_BLOCKSIZE);

$_tapetype_key_VALUES{"TAPETYPE_BLOCKSIZE"} = $TAPETYPE_BLOCKSIZE;

push @EXPORT_OK, qw($TAPETYPE_READBLOCKSIZE);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_READBLOCKSIZE);

$_tapetype_key_VALUES{"TAPETYPE_READBLOCKSIZE"} = $TAPETYPE_READBLOCKSIZE;

push @EXPORT_OK, qw($TAPETYPE_LENGTH);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_LENGTH);

$_tapetype_key_VALUES{"TAPETYPE_LENGTH"} = $TAPETYPE_LENGTH;

push @EXPORT_OK, qw($TAPETYPE_FILEMARK);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_FILEMARK);

$_tapetype_key_VALUES{"TAPETYPE_FILEMARK"} = $TAPETYPE_FILEMARK;

push @EXPORT_OK, qw($TAPETYPE_SPEED);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_SPEED);

$_tapetype_key_VALUES{"TAPETYPE_SPEED"} = $TAPETYPE_SPEED;

push @EXPORT_OK, qw($TAPETYPE_FILE_PAD);
push @{$EXPORT_TAGS{"tapetype_key"}}, qw($TAPETYPE_FILE_PAD);

$_tapetype_key_VALUES{"TAPETYPE_FILE_PAD"} = $TAPETYPE_FILE_PAD;

#copy symbols in tapetype_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"tapetype_key"}};

push @EXPORT_OK, qw(dumptype_key_to_string);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw(dumptype_key_to_string);

my %_dumptype_key_VALUES;
#Convert an enum value to a single string
sub dumptype_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_dumptype_key_VALUES) {
	my $v = $_dumptype_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($DUMPTYPE_COMMENT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_COMMENT);

$_dumptype_key_VALUES{"DUMPTYPE_COMMENT"} = $DUMPTYPE_COMMENT;

push @EXPORT_OK, qw($DUMPTYPE_PROGRAM);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_PROGRAM);

$_dumptype_key_VALUES{"DUMPTYPE_PROGRAM"} = $DUMPTYPE_PROGRAM;

push @EXPORT_OK, qw($DUMPTYPE_SRVCOMPPROG);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SRVCOMPPROG);

$_dumptype_key_VALUES{"DUMPTYPE_SRVCOMPPROG"} = $DUMPTYPE_SRVCOMPPROG;

push @EXPORT_OK, qw($DUMPTYPE_CLNTCOMPPROG);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_CLNTCOMPPROG);

$_dumptype_key_VALUES{"DUMPTYPE_CLNTCOMPPROG"} = $DUMPTYPE_CLNTCOMPPROG;

push @EXPORT_OK, qw($DUMPTYPE_SRV_ENCRYPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SRV_ENCRYPT);

$_dumptype_key_VALUES{"DUMPTYPE_SRV_ENCRYPT"} = $DUMPTYPE_SRV_ENCRYPT;

push @EXPORT_OK, qw($DUMPTYPE_CLNT_ENCRYPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_CLNT_ENCRYPT);

$_dumptype_key_VALUES{"DUMPTYPE_CLNT_ENCRYPT"} = $DUMPTYPE_CLNT_ENCRYPT;

push @EXPORT_OK, qw($DUMPTYPE_AMANDAD_PATH);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_AMANDAD_PATH);

$_dumptype_key_VALUES{"DUMPTYPE_AMANDAD_PATH"} = $DUMPTYPE_AMANDAD_PATH;

push @EXPORT_OK, qw($DUMPTYPE_CLIENT_USERNAME);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_CLIENT_USERNAME);

$_dumptype_key_VALUES{"DUMPTYPE_CLIENT_USERNAME"} = $DUMPTYPE_CLIENT_USERNAME;

push @EXPORT_OK, qw($DUMPTYPE_SSH_KEYS);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SSH_KEYS);

$_dumptype_key_VALUES{"DUMPTYPE_SSH_KEYS"} = $DUMPTYPE_SSH_KEYS;

push @EXPORT_OK, qw($DUMPTYPE_SECURITY_DRIVER);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SECURITY_DRIVER);

$_dumptype_key_VALUES{"DUMPTYPE_SECURITY_DRIVER"} = $DUMPTYPE_SECURITY_DRIVER;

push @EXPORT_OK, qw($DUMPTYPE_EXCLUDE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_EXCLUDE);

$_dumptype_key_VALUES{"DUMPTYPE_EXCLUDE"} = $DUMPTYPE_EXCLUDE;

push @EXPORT_OK, qw($DUMPTYPE_INCLUDE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_INCLUDE);

$_dumptype_key_VALUES{"DUMPTYPE_INCLUDE"} = $DUMPTYPE_INCLUDE;

push @EXPORT_OK, qw($DUMPTYPE_PRIORITY);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_PRIORITY);

$_dumptype_key_VALUES{"DUMPTYPE_PRIORITY"} = $DUMPTYPE_PRIORITY;

push @EXPORT_OK, qw($DUMPTYPE_DUMPCYCLE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_DUMPCYCLE);

$_dumptype_key_VALUES{"DUMPTYPE_DUMPCYCLE"} = $DUMPTYPE_DUMPCYCLE;

push @EXPORT_OK, qw($DUMPTYPE_MAXDUMPS);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_MAXDUMPS);

$_dumptype_key_VALUES{"DUMPTYPE_MAXDUMPS"} = $DUMPTYPE_MAXDUMPS;

push @EXPORT_OK, qw($DUMPTYPE_MAXPROMOTEDAY);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_MAXPROMOTEDAY);

$_dumptype_key_VALUES{"DUMPTYPE_MAXPROMOTEDAY"} = $DUMPTYPE_MAXPROMOTEDAY;

push @EXPORT_OK, qw($DUMPTYPE_BUMPPERCENT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_BUMPPERCENT);

$_dumptype_key_VALUES{"DUMPTYPE_BUMPPERCENT"} = $DUMPTYPE_BUMPPERCENT;

push @EXPORT_OK, qw($DUMPTYPE_BUMPSIZE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_BUMPSIZE);

$_dumptype_key_VALUES{"DUMPTYPE_BUMPSIZE"} = $DUMPTYPE_BUMPSIZE;

push @EXPORT_OK, qw($DUMPTYPE_BUMPDAYS);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_BUMPDAYS);

$_dumptype_key_VALUES{"DUMPTYPE_BUMPDAYS"} = $DUMPTYPE_BUMPDAYS;

push @EXPORT_OK, qw($DUMPTYPE_BUMPMULT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_BUMPMULT);

$_dumptype_key_VALUES{"DUMPTYPE_BUMPMULT"} = $DUMPTYPE_BUMPMULT;

push @EXPORT_OK, qw($DUMPTYPE_STARTTIME);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_STARTTIME);

$_dumptype_key_VALUES{"DUMPTYPE_STARTTIME"} = $DUMPTYPE_STARTTIME;

push @EXPORT_OK, qw($DUMPTYPE_STRATEGY);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_STRATEGY);

$_dumptype_key_VALUES{"DUMPTYPE_STRATEGY"} = $DUMPTYPE_STRATEGY;

push @EXPORT_OK, qw($DUMPTYPE_ESTIMATE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_ESTIMATE);

$_dumptype_key_VALUES{"DUMPTYPE_ESTIMATE"} = $DUMPTYPE_ESTIMATE;

push @EXPORT_OK, qw($DUMPTYPE_COMPRESS);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_COMPRESS);

$_dumptype_key_VALUES{"DUMPTYPE_COMPRESS"} = $DUMPTYPE_COMPRESS;

push @EXPORT_OK, qw($DUMPTYPE_ENCRYPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_ENCRYPT);

$_dumptype_key_VALUES{"DUMPTYPE_ENCRYPT"} = $DUMPTYPE_ENCRYPT;

push @EXPORT_OK, qw($DUMPTYPE_SRV_DECRYPT_OPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SRV_DECRYPT_OPT);

$_dumptype_key_VALUES{"DUMPTYPE_SRV_DECRYPT_OPT"} = $DUMPTYPE_SRV_DECRYPT_OPT;

push @EXPORT_OK, qw($DUMPTYPE_CLNT_DECRYPT_OPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_CLNT_DECRYPT_OPT);

$_dumptype_key_VALUES{"DUMPTYPE_CLNT_DECRYPT_OPT"} = $DUMPTYPE_CLNT_DECRYPT_OPT;

push @EXPORT_OK, qw($DUMPTYPE_COMPRATE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_COMPRATE);

$_dumptype_key_VALUES{"DUMPTYPE_COMPRATE"} = $DUMPTYPE_COMPRATE;

push @EXPORT_OK, qw($DUMPTYPE_TAPE_SPLITSIZE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_TAPE_SPLITSIZE);

$_dumptype_key_VALUES{"DUMPTYPE_TAPE_SPLITSIZE"} = $DUMPTYPE_TAPE_SPLITSIZE;

push @EXPORT_OK, qw($DUMPTYPE_FALLBACK_SPLITSIZE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_FALLBACK_SPLITSIZE);

$_dumptype_key_VALUES{"DUMPTYPE_FALLBACK_SPLITSIZE"} = $DUMPTYPE_FALLBACK_SPLITSIZE;

push @EXPORT_OK, qw($DUMPTYPE_SPLIT_DISKBUFFER);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SPLIT_DISKBUFFER);

$_dumptype_key_VALUES{"DUMPTYPE_SPLIT_DISKBUFFER"} = $DUMPTYPE_SPLIT_DISKBUFFER;

push @EXPORT_OK, qw($DUMPTYPE_RECORD);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_RECORD);

$_dumptype_key_VALUES{"DUMPTYPE_RECORD"} = $DUMPTYPE_RECORD;

push @EXPORT_OK, qw($DUMPTYPE_SKIP_INCR);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SKIP_INCR);

$_dumptype_key_VALUES{"DUMPTYPE_SKIP_INCR"} = $DUMPTYPE_SKIP_INCR;

push @EXPORT_OK, qw($DUMPTYPE_SKIP_FULL);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_SKIP_FULL);

$_dumptype_key_VALUES{"DUMPTYPE_SKIP_FULL"} = $DUMPTYPE_SKIP_FULL;

push @EXPORT_OK, qw($DUMPTYPE_HOLDINGDISK);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_HOLDINGDISK);

$_dumptype_key_VALUES{"DUMPTYPE_HOLDINGDISK"} = $DUMPTYPE_HOLDINGDISK;

push @EXPORT_OK, qw($DUMPTYPE_KENCRYPT);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_KENCRYPT);

$_dumptype_key_VALUES{"DUMPTYPE_KENCRYPT"} = $DUMPTYPE_KENCRYPT;

push @EXPORT_OK, qw($DUMPTYPE_IGNORE);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_IGNORE);

$_dumptype_key_VALUES{"DUMPTYPE_IGNORE"} = $DUMPTYPE_IGNORE;

push @EXPORT_OK, qw($DUMPTYPE_INDEX);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_INDEX);

$_dumptype_key_VALUES{"DUMPTYPE_INDEX"} = $DUMPTYPE_INDEX;

push @EXPORT_OK, qw($DUMPTYPE_APPLICATION);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_APPLICATION);

$_dumptype_key_VALUES{"DUMPTYPE_APPLICATION"} = $DUMPTYPE_APPLICATION;

push @EXPORT_OK, qw($DUMPTYPE_PP_SCRIPTLIST);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_PP_SCRIPTLIST);

$_dumptype_key_VALUES{"DUMPTYPE_PP_SCRIPTLIST"} = $DUMPTYPE_PP_SCRIPTLIST;

push @EXPORT_OK, qw($DUMPTYPE_PROPERTY);
push @{$EXPORT_TAGS{"dumptype_key"}}, qw($DUMPTYPE_PROPERTY);

$_dumptype_key_VALUES{"DUMPTYPE_PROPERTY"} = $DUMPTYPE_PROPERTY;

#copy symbols in dumptype_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"dumptype_key"}};

push @EXPORT_OK, qw(interface_key_to_string);
push @{$EXPORT_TAGS{"interface_key"}}, qw(interface_key_to_string);

my %_interface_key_VALUES;
#Convert an enum value to a single string
sub interface_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_interface_key_VALUES) {
	my $v = $_interface_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($INTER_COMMENT);
push @{$EXPORT_TAGS{"interface_key"}}, qw($INTER_COMMENT);

$_interface_key_VALUES{"INTER_COMMENT"} = $INTER_COMMENT;

push @EXPORT_OK, qw($INTER_MAXUSAGE);
push @{$EXPORT_TAGS{"interface_key"}}, qw($INTER_MAXUSAGE);

$_interface_key_VALUES{"INTER_MAXUSAGE"} = $INTER_MAXUSAGE;

#copy symbols in interface_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"interface_key"}};

push @EXPORT_OK, qw(holdingdisk_key_to_string);
push @{$EXPORT_TAGS{"holdingdisk_key"}}, qw(holdingdisk_key_to_string);

my %_holdingdisk_key_VALUES;
#Convert an enum value to a single string
sub holdingdisk_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_holdingdisk_key_VALUES) {
	my $v = $_holdingdisk_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($HOLDING_COMMENT);
push @{$EXPORT_TAGS{"holdingdisk_key"}}, qw($HOLDING_COMMENT);

$_holdingdisk_key_VALUES{"HOLDING_COMMENT"} = $HOLDING_COMMENT;

push @EXPORT_OK, qw($HOLDING_DISKDIR);
push @{$EXPORT_TAGS{"holdingdisk_key"}}, qw($HOLDING_DISKDIR);

$_holdingdisk_key_VALUES{"HOLDING_DISKDIR"} = $HOLDING_DISKDIR;

push @EXPORT_OK, qw($HOLDING_DISKSIZE);
push @{$EXPORT_TAGS{"holdingdisk_key"}}, qw($HOLDING_DISKSIZE);

$_holdingdisk_key_VALUES{"HOLDING_DISKSIZE"} = $HOLDING_DISKSIZE;

push @EXPORT_OK, qw($HOLDING_CHUNKSIZE);
push @{$EXPORT_TAGS{"holdingdisk_key"}}, qw($HOLDING_CHUNKSIZE);

$_holdingdisk_key_VALUES{"HOLDING_CHUNKSIZE"} = $HOLDING_CHUNKSIZE;

#copy symbols in holdingdisk_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"holdingdisk_key"}};

push @EXPORT_OK, qw(application_key_to_string);
push @{$EXPORT_TAGS{"application_key"}}, qw(application_key_to_string);

my %_application_key_VALUES;
#Convert an enum value to a single string
sub application_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_application_key_VALUES) {
	my $v = $_application_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($APPLICATION_COMMENT);
push @{$EXPORT_TAGS{"application_key"}}, qw($APPLICATION_COMMENT);

$_application_key_VALUES{"APPLICATION_COMMENT"} = $APPLICATION_COMMENT;

push @EXPORT_OK, qw($APPLICATION_PLUGIN);
push @{$EXPORT_TAGS{"application_key"}}, qw($APPLICATION_PLUGIN);

$_application_key_VALUES{"APPLICATION_PLUGIN"} = $APPLICATION_PLUGIN;

push @EXPORT_OK, qw($APPLICATION_PROPERTY);
push @{$EXPORT_TAGS{"application_key"}}, qw($APPLICATION_PROPERTY);

$_application_key_VALUES{"APPLICATION_PROPERTY"} = $APPLICATION_PROPERTY;

#copy symbols in application_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"application_key"}};

push @EXPORT_OK, qw(pp_script_key_to_string);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw(pp_script_key_to_string);

my %_pp_script_key_VALUES;
#Convert an enum value to a single string
sub pp_script_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_pp_script_key_VALUES) {
	my $v = $_pp_script_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($PP_SCRIPT_COMMENT);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw($PP_SCRIPT_COMMENT);

$_pp_script_key_VALUES{"PP_SCRIPT_COMMENT"} = $PP_SCRIPT_COMMENT;

push @EXPORT_OK, qw($PP_SCRIPT_PLUGIN);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw($PP_SCRIPT_PLUGIN);

$_pp_script_key_VALUES{"PP_SCRIPT_PLUGIN"} = $PP_SCRIPT_PLUGIN;

push @EXPORT_OK, qw($PP_SCRIPT_PROPERTY);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw($PP_SCRIPT_PROPERTY);

$_pp_script_key_VALUES{"PP_SCRIPT_PROPERTY"} = $PP_SCRIPT_PROPERTY;

push @EXPORT_OK, qw($PP_SCRIPT_EXECUTE_ON);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw($PP_SCRIPT_EXECUTE_ON);

$_pp_script_key_VALUES{"PP_SCRIPT_EXECUTE_ON"} = $PP_SCRIPT_EXECUTE_ON;

push @EXPORT_OK, qw($PP_SCRIPT_EXECUTE_WHERE);
push @{$EXPORT_TAGS{"pp_script_key"}}, qw($PP_SCRIPT_EXECUTE_WHERE);

$_pp_script_key_VALUES{"PP_SCRIPT_EXECUTE_WHERE"} = $PP_SCRIPT_EXECUTE_WHERE;

#copy symbols in pp_script_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"pp_script_key"}};

push @EXPORT_OK, qw(device_config_key_to_string);
push @{$EXPORT_TAGS{"device_config_key"}}, qw(device_config_key_to_string);

my %_device_config_key_VALUES;
#Convert an enum value to a single string
sub device_config_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_device_config_key_VALUES) {
	my $v = $_device_config_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($DEVICE_CONFIG_COMMENT);
push @{$EXPORT_TAGS{"device_config_key"}}, qw($DEVICE_CONFIG_COMMENT);

$_device_config_key_VALUES{"DEVICE_CONFIG_COMMENT"} = $DEVICE_CONFIG_COMMENT;

push @EXPORT_OK, qw($DEVICE_CONFIG_TAPEDEV);
push @{$EXPORT_TAGS{"device_config_key"}}, qw($DEVICE_CONFIG_TAPEDEV);

$_device_config_key_VALUES{"DEVICE_CONFIG_TAPEDEV"} = $DEVICE_CONFIG_TAPEDEV;

push @EXPORT_OK, qw($DEVICE_CONFIG_DEVICE_PROPERTY);
push @{$EXPORT_TAGS{"device_config_key"}}, qw($DEVICE_CONFIG_DEVICE_PROPERTY);

$_device_config_key_VALUES{"DEVICE_CONFIG_DEVICE_PROPERTY"} = $DEVICE_CONFIG_DEVICE_PROPERTY;

#copy symbols in device_config_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"device_config_key"}};

push @EXPORT_OK, qw(changer_config_key_to_string);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw(changer_config_key_to_string);

my %_changer_config_key_VALUES;
#Convert an enum value to a single string
sub changer_config_key_to_string {
    my ($enumval) = @_;

    for my $k (keys %_changer_config_key_VALUES) {
	my $v = $_changer_config_key_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($CHANGER_CONFIG_COMMENT);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw($CHANGER_CONFIG_COMMENT);

$_changer_config_key_VALUES{"CHANGER_CONFIG_COMMENT"} = $CHANGER_CONFIG_COMMENT;

push @EXPORT_OK, qw($CHANGER_CONFIG_TAPEDEV);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw($CHANGER_CONFIG_TAPEDEV);

$_changer_config_key_VALUES{"CHANGER_CONFIG_TAPEDEV"} = $CHANGER_CONFIG_TAPEDEV;

push @EXPORT_OK, qw($CHANGER_CONFIG_TPCHANGER);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw($CHANGER_CONFIG_TPCHANGER);

$_changer_config_key_VALUES{"CHANGER_CONFIG_TPCHANGER"} = $CHANGER_CONFIG_TPCHANGER;

push @EXPORT_OK, qw($CHANGER_CONFIG_CHANGERDEV);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw($CHANGER_CONFIG_CHANGERDEV);

$_changer_config_key_VALUES{"CHANGER_CONFIG_CHANGERDEV"} = $CHANGER_CONFIG_CHANGERDEV;

push @EXPORT_OK, qw($CHANGER_CONFIG_CHANGERFILE);
push @{$EXPORT_TAGS{"changer_config_key"}}, qw($CHANGER_CONFIG_CHANGERFILE);

$_changer_config_key_VALUES{"CHANGER_CONFIG_CHANGERFILE"} = $CHANGER_CONFIG_CHANGERFILE;

#copy symbols in changer_config_key to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"changer_config_key"}};

push @EXPORT_OK, qw(dump_holdingdisk_t_to_string);
push @{$EXPORT_TAGS{"dump_holdingdisk_t"}}, qw(dump_holdingdisk_t_to_string);

my %_dump_holdingdisk_t_VALUES;
#Convert an enum value to a single string
sub dump_holdingdisk_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_dump_holdingdisk_t_VALUES) {
	my $v = $_dump_holdingdisk_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($HOLD_NEVER);
push @{$EXPORT_TAGS{"dump_holdingdisk_t"}}, qw($HOLD_NEVER);

$_dump_holdingdisk_t_VALUES{"HOLD_NEVER"} = $HOLD_NEVER;

push @EXPORT_OK, qw($HOLD_AUTO);
push @{$EXPORT_TAGS{"dump_holdingdisk_t"}}, qw($HOLD_AUTO);

$_dump_holdingdisk_t_VALUES{"HOLD_AUTO"} = $HOLD_AUTO;

push @EXPORT_OK, qw($HOLD_REQUIRED);
push @{$EXPORT_TAGS{"dump_holdingdisk_t"}}, qw($HOLD_REQUIRED);

$_dump_holdingdisk_t_VALUES{"HOLD_REQUIRED"} = $HOLD_REQUIRED;

#copy symbols in dump_holdingdisk_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"dump_holdingdisk_t"}};

push @EXPORT_OK, qw(comp_t_to_string);
push @{$EXPORT_TAGS{"comp_t"}}, qw(comp_t_to_string);

my %_comp_t_VALUES;
#Convert an enum value to a single string
sub comp_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_comp_t_VALUES) {
	my $v = $_comp_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($COMP_NONE);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_NONE);

$_comp_t_VALUES{"COMP_NONE"} = $COMP_NONE;

push @EXPORT_OK, qw($COMP_FAST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_FAST);

$_comp_t_VALUES{"COMP_FAST"} = $COMP_FAST;

push @EXPORT_OK, qw($COMP_BEST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_BEST);

$_comp_t_VALUES{"COMP_BEST"} = $COMP_BEST;

push @EXPORT_OK, qw($COMP_CUST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_CUST);

$_comp_t_VALUES{"COMP_CUST"} = $COMP_CUST;

push @EXPORT_OK, qw($COMP_SERVER_FAST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_SERVER_FAST);

$_comp_t_VALUES{"COMP_SERVER_FAST"} = $COMP_SERVER_FAST;

push @EXPORT_OK, qw($COMP_SERVER_BEST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_SERVER_BEST);

$_comp_t_VALUES{"COMP_SERVER_BEST"} = $COMP_SERVER_BEST;

push @EXPORT_OK, qw($COMP_SERVER_CUST);
push @{$EXPORT_TAGS{"comp_t"}}, qw($COMP_SERVER_CUST);

$_comp_t_VALUES{"COMP_SERVER_CUST"} = $COMP_SERVER_CUST;

#copy symbols in comp_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"comp_t"}};

push @EXPORT_OK, qw(encrypt_t_to_string);
push @{$EXPORT_TAGS{"encrypt_t"}}, qw(encrypt_t_to_string);

my %_encrypt_t_VALUES;
#Convert an enum value to a single string
sub encrypt_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_encrypt_t_VALUES) {
	my $v = $_encrypt_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($ENCRYPT_NONE);
push @{$EXPORT_TAGS{"encrypt_t"}}, qw($ENCRYPT_NONE);

$_encrypt_t_VALUES{"ENCRYPT_NONE"} = $ENCRYPT_NONE;

push @EXPORT_OK, qw($ENCRYPT_CUST);
push @{$EXPORT_TAGS{"encrypt_t"}}, qw($ENCRYPT_CUST);

$_encrypt_t_VALUES{"ENCRYPT_CUST"} = $ENCRYPT_CUST;

push @EXPORT_OK, qw($ENCRYPT_SERV_CUST);
push @{$EXPORT_TAGS{"encrypt_t"}}, qw($ENCRYPT_SERV_CUST);

$_encrypt_t_VALUES{"ENCRYPT_SERV_CUST"} = $ENCRYPT_SERV_CUST;

#copy symbols in encrypt_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"encrypt_t"}};

push @EXPORT_OK, qw(strategy_t_to_string);
push @{$EXPORT_TAGS{"strategy_t"}}, qw(strategy_t_to_string);

my %_strategy_t_VALUES;
#Convert an enum value to a single string
sub strategy_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_strategy_t_VALUES) {
	my $v = $_strategy_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($DS_SKIP);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_SKIP);

$_strategy_t_VALUES{"DS_SKIP"} = $DS_SKIP;

push @EXPORT_OK, qw($DS_STANDARD);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_STANDARD);

$_strategy_t_VALUES{"DS_STANDARD"} = $DS_STANDARD;

push @EXPORT_OK, qw($DS_NOFULL);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_NOFULL);

$_strategy_t_VALUES{"DS_NOFULL"} = $DS_NOFULL;

push @EXPORT_OK, qw($DS_NOINC);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_NOINC);

$_strategy_t_VALUES{"DS_NOINC"} = $DS_NOINC;

push @EXPORT_OK, qw($DS_4);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_4);

$_strategy_t_VALUES{"DS_4"} = $DS_4;

push @EXPORT_OK, qw($DS_5);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_5);

$_strategy_t_VALUES{"DS_5"} = $DS_5;

push @EXPORT_OK, qw($DS_HANOI);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_HANOI);

$_strategy_t_VALUES{"DS_HANOI"} = $DS_HANOI;

push @EXPORT_OK, qw($DS_INCRONLY);
push @{$EXPORT_TAGS{"strategy_t"}}, qw($DS_INCRONLY);

$_strategy_t_VALUES{"DS_INCRONLY"} = $DS_INCRONLY;

#copy symbols in strategy_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"strategy_t"}};

push @EXPORT_OK, qw(estimate_t_to_string);
push @{$EXPORT_TAGS{"estimate_t"}}, qw(estimate_t_to_string);

my %_estimate_t_VALUES;
#Convert an enum value to a single string
sub estimate_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_estimate_t_VALUES) {
	my $v = $_estimate_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($ES_CLIENT);
push @{$EXPORT_TAGS{"estimate_t"}}, qw($ES_CLIENT);

$_estimate_t_VALUES{"ES_CLIENT"} = $ES_CLIENT;

push @EXPORT_OK, qw($ES_SERVER);
push @{$EXPORT_TAGS{"estimate_t"}}, qw($ES_SERVER);

$_estimate_t_VALUES{"ES_SERVER"} = $ES_SERVER;

push @EXPORT_OK, qw($ES_CALCSIZE);
push @{$EXPORT_TAGS{"estimate_t"}}, qw($ES_CALCSIZE);

$_estimate_t_VALUES{"ES_CALCSIZE"} = $ES_CALCSIZE;

#copy symbols in estimate_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"estimate_t"}};

push @EXPORT_OK, qw(taperalgo_t_to_string);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw(taperalgo_t_to_string);

my %_taperalgo_t_VALUES;
#Convert an enum value to a single string
sub taperalgo_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_taperalgo_t_VALUES) {
	my $v = $_taperalgo_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($ALGO_FIRST);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_FIRST);

$_taperalgo_t_VALUES{"ALGO_FIRST"} = $ALGO_FIRST;

push @EXPORT_OK, qw($ALGO_FIRSTFIT);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_FIRSTFIT);

$_taperalgo_t_VALUES{"ALGO_FIRSTFIT"} = $ALGO_FIRSTFIT;

push @EXPORT_OK, qw($ALGO_LARGEST);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_LARGEST);

$_taperalgo_t_VALUES{"ALGO_LARGEST"} = $ALGO_LARGEST;

push @EXPORT_OK, qw($ALGO_LARGESTFIT);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_LARGESTFIT);

$_taperalgo_t_VALUES{"ALGO_LARGESTFIT"} = $ALGO_LARGESTFIT;

push @EXPORT_OK, qw($ALGO_SMALLEST);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_SMALLEST);

$_taperalgo_t_VALUES{"ALGO_SMALLEST"} = $ALGO_SMALLEST;

push @EXPORT_OK, qw($ALGO_LAST);
push @{$EXPORT_TAGS{"taperalgo_t"}}, qw($ALGO_LAST);

$_taperalgo_t_VALUES{"ALGO_LAST"} = $ALGO_LAST;

#copy symbols in taperalgo_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"taperalgo_t"}};

push @EXPORT_OK, qw(execute_on_t_to_string);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw(execute_on_t_to_string);

my %_execute_on_t_VALUES;
#Convert an enum value to a single string
sub execute_on_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_execute_on_t_VALUES) {
	my $v = $_execute_on_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($EXECUTE_ON_PRE_DLE_AMCHECK);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_DLE_AMCHECK);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_DLE_AMCHECK"} = $EXECUTE_ON_PRE_DLE_AMCHECK;

push @EXPORT_OK, qw($EXECUTE_ON_PRE_HOST_AMCHECK);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_HOST_AMCHECK);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_HOST_AMCHECK"} = $EXECUTE_ON_PRE_HOST_AMCHECK;

push @EXPORT_OK, qw($EXECUTE_ON_POST_DLE_AMCHECK);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_DLE_AMCHECK);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_DLE_AMCHECK"} = $EXECUTE_ON_POST_DLE_AMCHECK;

push @EXPORT_OK, qw($EXECUTE_ON_POST_HOST_AMCHECK);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_HOST_AMCHECK);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_HOST_AMCHECK"} = $EXECUTE_ON_POST_HOST_AMCHECK;

push @EXPORT_OK, qw($EXECUTE_ON_PRE_DLE_ESTIMATE);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_DLE_ESTIMATE);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_DLE_ESTIMATE"} = $EXECUTE_ON_PRE_DLE_ESTIMATE;

push @EXPORT_OK, qw($EXECUTE_ON_PRE_HOST_ESTIMATE);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_HOST_ESTIMATE);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_HOST_ESTIMATE"} = $EXECUTE_ON_PRE_HOST_ESTIMATE;

push @EXPORT_OK, qw($EXECUTE_ON_POST_DLE_ESTIMATE);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_DLE_ESTIMATE);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_DLE_ESTIMATE"} = $EXECUTE_ON_POST_DLE_ESTIMATE;

push @EXPORT_OK, qw($EXECUTE_ON_POST_HOST_ESTIMATE);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_HOST_ESTIMATE);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_HOST_ESTIMATE"} = $EXECUTE_ON_POST_HOST_ESTIMATE;

push @EXPORT_OK, qw($EXECUTE_ON_PRE_DLE_BACKUP);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_DLE_BACKUP);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_DLE_BACKUP"} = $EXECUTE_ON_PRE_DLE_BACKUP;

push @EXPORT_OK, qw($EXECUTE_ON_PRE_HOST_BACKUP);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_PRE_HOST_BACKUP);

$_execute_on_t_VALUES{"EXECUTE_ON_PRE_HOST_BACKUP"} = $EXECUTE_ON_PRE_HOST_BACKUP;

push @EXPORT_OK, qw($EXECUTE_ON_POST_DLE_BACKUP);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_DLE_BACKUP);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_DLE_BACKUP"} = $EXECUTE_ON_POST_DLE_BACKUP;

push @EXPORT_OK, qw($EXECUTE_ON_POST_HOST_BACKUP);
push @{$EXPORT_TAGS{"execute_on_t"}}, qw($EXECUTE_ON_POST_HOST_BACKUP);

$_execute_on_t_VALUES{"EXECUTE_ON_POST_HOST_BACKUP"} = $EXECUTE_ON_POST_HOST_BACKUP;

#copy symbols in execute_on_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"execute_on_t"}};

push @EXPORT_OK, qw(send_amreport_on_t_to_string);
push @{$EXPORT_TAGS{"send_amreport_on_t"}}, qw(send_amreport_on_t_to_string);

my %_send_amreport_on_t_VALUES;
#Convert an enum value to a single string
sub send_amreport_on_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_send_amreport_on_t_VALUES) {
	my $v = $_send_amreport_on_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($SEND_AMREPORT_ALL);
push @{$EXPORT_TAGS{"send_amreport_on_t"}}, qw($SEND_AMREPORT_ALL);

$_send_amreport_on_t_VALUES{"SEND_AMREPORT_ALL"} = $SEND_AMREPORT_ALL;

push @EXPORT_OK, qw($SEND_AMREPORT_STRANGE);
push @{$EXPORT_TAGS{"send_amreport_on_t"}}, qw($SEND_AMREPORT_STRANGE);

$_send_amreport_on_t_VALUES{"SEND_AMREPORT_STRANGE"} = $SEND_AMREPORT_STRANGE;

push @EXPORT_OK, qw($SEND_AMREPORT_ERROR);
push @{$EXPORT_TAGS{"send_amreport_on_t"}}, qw($SEND_AMREPORT_ERROR);

$_send_amreport_on_t_VALUES{"SEND_AMREPORT_ERROR"} = $SEND_AMREPORT_ERROR;

push @EXPORT_OK, qw($SEND_AMREPORT_NEVER);
push @{$EXPORT_TAGS{"send_amreport_on_t"}}, qw($SEND_AMREPORT_NEVER);

$_send_amreport_on_t_VALUES{"SEND_AMREPORT_NEVER"} = $SEND_AMREPORT_NEVER;

#copy symbols in send_amreport_on_t to getconf
push @{$EXPORT_TAGS{"getconf"}},  @{$EXPORT_TAGS{"send_amreport_on_t"}};

push @EXPORT_OK, qw(getconf getconf_seen 
    getconf_byname getconf_byname_strs
    getconf_list);
push @{$EXPORT_TAGS{"getconf"}}, qw(getconf getconf_seen 
    getconf_byname getconf_byname_strs
    getconf_list);

push @EXPORT_OK, qw(lookup_tapetype tapetype_getconf tapetype_name
    tapetype_seen tapetype_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_tapetype tapetype_getconf tapetype_name
    tapetype_seen tapetype_seen);

push @EXPORT_OK, qw(lookup_dumptype dumptype_getconf dumptype_name
    dumptype_seen dumptype_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_dumptype dumptype_getconf dumptype_name
    dumptype_seen dumptype_seen);

push @EXPORT_OK, qw(lookup_interface interface_getconf interface_name
    interface_seen interface_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_interface interface_getconf interface_name
    interface_seen interface_seen);

push @EXPORT_OK, qw(lookup_holdingdisk holdingdisk_getconf holdingdisk_name
    getconf_holdingdisks holdingdisk_next
    holdingdisk_seen holdingdisk_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_holdingdisk holdingdisk_getconf holdingdisk_name
    getconf_holdingdisks holdingdisk_next
    holdingdisk_seen holdingdisk_seen);

push @EXPORT_OK, qw(lookup_application application_getconf application_name
    application_seen application_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_application application_getconf application_name
    application_seen application_seen);

push @EXPORT_OK, qw(lookup_pp_script pp_script_getconf pp_script_name
    pp_script_seen pp_script_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_pp_script pp_script_getconf pp_script_name
    pp_script_seen pp_script_seen);

push @EXPORT_OK, qw(lookup_device_config device_config_getconf device_config_name
    device_config_seen device_config_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_device_config device_config_getconf device_config_name
    device_config_seen device_config_seen);

push @EXPORT_OK, qw(lookup_changer_config changer_config_getconf changer_config_name
    changer_config_seen changer_config_seen);
push @{$EXPORT_TAGS{"getconf"}}, qw(lookup_changer_config changer_config_getconf changer_config_name
    changer_config_seen changer_config_seen);

our %subsection_names = (
    "tapetype" => 1,
    "dumptype" => 1,
    "interface" => 1,
    "holdingdisk" => 1,
    "application-tool" => 1,
    "script-tool" => 1,
    "device" => 1,
    "changer" => 1,
);

push @EXPORT_OK, qw(%subsection_names);
push @{$EXPORT_TAGS{"getconf"}}, qw(%subsection_names);

push @EXPORT_OK, qw(getconf_unit_divisor

    $debug_amandad $debug_amidxtaped $debug_amindexd $debug_amrecover
    $debug_auth $debug_event $debug_holding $debug_protocol
    $debug_planner $debug_driver $debug_dumper $debug_chunker
    $debug_taper $debug_selfcheck $debug_sendsize $debug_sendbackup);
push @{$EXPORT_TAGS{"getconf"}}, qw(getconf_unit_divisor

    $debug_amandad $debug_amidxtaped $debug_amindexd $debug_amrecover
    $debug_auth $debug_event $debug_holding $debug_protocol
    $debug_planner $debug_driver $debug_dumper $debug_chunker
    $debug_taper $debug_selfcheck $debug_sendsize $debug_sendbackup);

push @EXPORT_OK, qw(cfgerr_level_t_to_string);
push @{$EXPORT_TAGS{"cfgerr_level_t"}}, qw(cfgerr_level_t_to_string);

my %_cfgerr_level_t_VALUES;
#Convert an enum value to a single string
sub cfgerr_level_t_to_string {
    my ($enumval) = @_;

    for my $k (keys %_cfgerr_level_t_VALUES) {
	my $v = $_cfgerr_level_t_VALUES{$k};

	#is this a matching flag?
	if ($enumval == $v) {
	    return $k;
	}
    }

#default, just return the number
    return $enumval;
}

push @EXPORT_OK, qw($CFGERR_OK);
push @{$EXPORT_TAGS{"cfgerr_level_t"}}, qw($CFGERR_OK);

$_cfgerr_level_t_VALUES{"CFGERR_OK"} = $CFGERR_OK;

push @EXPORT_OK, qw($CFGERR_WARNINGS);
push @{$EXPORT_TAGS{"cfgerr_level_t"}}, qw($CFGERR_WARNINGS);

$_cfgerr_level_t_VALUES{"CFGERR_WARNINGS"} = $CFGERR_WARNINGS;

push @EXPORT_OK, qw($CFGERR_ERRORS);
push @{$EXPORT_TAGS{"cfgerr_level_t"}}, qw($CFGERR_ERRORS);

$_cfgerr_level_t_VALUES{"CFGERR_ERRORS"} = $CFGERR_ERRORS;

#copy symbols in cfgerr_level_t to init
push @{$EXPORT_TAGS{"init"}},  @{$EXPORT_TAGS{"cfgerr_level_t"}};

push @EXPORT_OK, qw(config_init_flags_to_strings);
push @{$EXPORT_TAGS{"config_init_flags"}}, qw(config_init_flags_to_strings);

my %_config_init_flags_VALUES;
#Convert a flag value to a list of names for flags that are set.
sub config_init_flags_to_strings {
    my ($flags) = @_;
    my @result = ();

    for my $k (keys %_config_init_flags_VALUES) {
	my $v = $_config_init_flags_VALUES{$k};

	#is this a matching flag?
	if (($v == 0 && $flags == 0) || ($v != 0 && ($flags & $v) == $v)) {
	    push @result, $k;
	}
    }

#by default, just return the number as a 1-element list
    if (!@result) {
	return ($flags);
    }

    return @result;
}

push @EXPORT_OK, qw($CONFIG_INIT_EXPLICIT_NAME);
push @{$EXPORT_TAGS{"config_init_flags"}}, qw($CONFIG_INIT_EXPLICIT_NAME);

$_config_init_flags_VALUES{"CONFIG_INIT_EXPLICIT_NAME"} = $CONFIG_INIT_EXPLICIT_NAME;

push @EXPORT_OK, qw($CONFIG_INIT_USE_CWD);
push @{$EXPORT_TAGS{"config_init_flags"}}, qw($CONFIG_INIT_USE_CWD);

$_config_init_flags_VALUES{"CONFIG_INIT_USE_CWD"} = $CONFIG_INIT_USE_CWD;

push @EXPORT_OK, qw($CONFIG_INIT_CLIENT);
push @{$EXPORT_TAGS{"config_init_flags"}}, qw($CONFIG_INIT_CLIENT);

$_config_init_flags_VALUES{"CONFIG_INIT_CLIENT"} = $CONFIG_INIT_CLIENT;

push @EXPORT_OK, qw($CONFIG_INIT_OVERLAY);
push @{$EXPORT_TAGS{"config_init_flags"}}, qw($CONFIG_INIT_OVERLAY);

$_config_init_flags_VALUES{"CONFIG_INIT_OVERLAY"} = $CONFIG_INIT_OVERLAY;

#copy symbols in config_init_flags to init
push @{$EXPORT_TAGS{"init"}},  @{$EXPORT_TAGS{"config_init_flags"}};

push @EXPORT_OK, qw(config_init config_uninit get_config_options
    get_config_name get_config_dir get_config_filename
    config_print_errors config_clear_errors config_errors
    new_config_overwrites free_config_overwrites add_config_overwrite
    add_config_overwrite_opt apply_config_overwrites);
push @{$EXPORT_TAGS{"init"}}, qw(config_init config_uninit get_config_options
    get_config_name get_config_dir get_config_filename
    config_print_errors config_clear_errors config_errors
    new_config_overwrites free_config_overwrites add_config_overwrite
    add_config_overwrite_opt apply_config_overwrites);

push @EXPORT_OK, qw(dump_configuration config_dir_relative taperalgo2str find_multiplier);
1;
