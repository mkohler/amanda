.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "AMTAPETYPE" 8 "" "" ""
.SH NAME
amtapetype \- generate a tapetype definition.
.SH "SYNOPSIS"
.ad l
.hy 0
.HP 11
\fBamtapetype\fR [\-h] [\-c] [\-o] [\-b\ \fIblocksize\fR] [\-e\ \fIestsize\fR] [\-f\ \fItapedev\fR] [\-t\ \fItypename\fR]
.ad
.hy

.SH "DESCRIPTION"

.PP
\fBamtapetype\fR generates a tapetype entry for \fBAMANDA\fR\&.

.SH "OPTIONS"

.TP
\fB\-h\fR
Display an help message\&.

.TP
\fB\-c\fR
Run only the hardware compression detection heuristic test and stop\&. This takes a few minutes only\&.

.TP
\fB\-o\fR
Overwrite the tape, even if it's an \fBAMANDA\fR tape\&.

.TP
\fB\-b\fR\fI&#8201; blocksize\fR
record block size (default: 32k)

.TP
\fB\-e\fR\fI&#8201; estsize\fR
estimated tape size (default: 1g == 1024m)

.TP
\fB\-f\fR\fI&#8201; tapedev\fR
tape device name (default: $TAPE) The device to perform the test\&.

.TP
\fB\-t\fR\fI&#8201; typename\fR
tapetype name (default: unknown\-tapetype)

.SH "EXAMPLE"

.PP
Generate a tapetype definition for your tape device:

.nf

% amtapetype \-f /dev/nst0

.fi

.SH "NOTES"

.PP
Hardware compression is detected by measuring the writing speed difference of the tape drive when writing an amount of compressable and uncompresseable data\&. It does not rely on the status bits of the tape drive or the OS parameters\&. If your tape drive has very large buffers or is very fast, the program could fail to detect hardware compression status reliably\&.

.PP
During the first pass, it writes files that are estimated to be 1% of the expected tape capacity\&. It gets the expected capacity from the \-e command line flag, or defaults to 1 GByte\&. In a perfect world (which means there is zero chance of this happening with tapes :\-), there would be 100 files and 100 file marks\&.

.PP
During the second pass, the file size is cut in half\&. In that same fairyland world, this means 200 files and 200 file marks\&.

.PP
In both passes the total amount of data written is summed as well as the number of file marks written\&. At the end of the second pass, quoting from the code:

.PP
* Compute the size of a filemark as the difference in data written between pass 1 and pass 2 divided by the difference in number of file marks written between pass 1 and pass 2\&. \&.\&.\&. *

.PP
So if we wrote 1\&.0 GBytes on the first pass and 100 file marks, and 0\&.9 GBytes on the second pass with 200 file marks, those additional 100 file marks in the second pass took 0\&.1 GBytes and therefor a file mark is 0\&.001 GBytes (1 MByte)\&.

.PP
Note that if the estimated capacity is wrong, the only thing that happens is a lot more (or less, but unlikely) files, and thus, file marks, get written\&. But the math still works out the same\&. The \-e flag is there to keep the number of file marks down because they can be slow (since they force the drive to flush all its buffers to physical media)\&.

.PP
All sorts of things might happen to cause the amount of data written to vary enough to generate a big file mark size guess\&. A little more ``\fBshoe shining\fR'' because of the additional file marks (and flushes), dirt left on the heads from the first pass of a brand new tape, the temperature/humidity changed during the multi\-hour run, a different amount of data was written after the last file mark before EOT was reported, etc\&.

.PP
Note that the file mark size might really be zero for whatever device this is, and it was just the measured capacity variation that caused \fBamtapetype\fR to think those extra file marks in pass 2 actually took up space\&.

.PP
It also explains why \fBamtapetype\fR used to sometimes report a negative file mark size if the math happened to end up that way\&. When that happens now we just report it as zero\&.

.SH "SEE ALSO"

.PP
\fBamanda\fR(8)

